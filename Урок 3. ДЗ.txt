Установка БД
    sudo yum install -y wget
    wget https://downloads.mariadb.com/MariaDB/mariadb_repo_setup
    chmod +x mariadb_repo_setup
    sudo ./mariadb_repo_setup
    sudo yum install MariaDB-server
    sudo systemctl start mariadb
Стартовать при загрузке
    sudo systemctl enable mariadb
Статус MariaDb
    sudo systemctl status mariadb
Установка БД
    sudo mariadb-secure-installation
        root password: Enter
        Switch to unix_socket authentication: no
        change root password: yes / root
        remove anonymous users : no
        Disallow root login remotely : no
        remove test database : no
        Reload privilege tables now: yes
Настройка доступа
    sudo nano /etc/my.cnf.d/server.cnf
        расскоментарить
        bind-address=0.0.0.0
Рестарт
        sudo systemctl restart mariadb
Посмотреть настройки
        mysqld --print-defaults
Устновить доступ с внешних адресов
        mysql -u root -p
        или
        sudo mysql -u root

        rename user 'root'@'localhost' to 'root'@'%';
        select Host,User from mysql.user; #Список пользователей

Можно зайти через MySql Workbanch
Залить данные. Скопировать через SFTP
    mysql -u test -p -D test < /vagrant/db/explain_models.sql;

План выполнения
    explain SELECT * FROM test.orders;

Ответы на вопросы:
1. Какие ситуации, вызывающие рост количества запросов, могут случаться на сервере? Мы рассмотрели не все.
    Как правило рост очереди запросов происходит из-за узких мест. В СУБД разделяют латчи, блокировки и дедлоки:
    1.1. Латчи - задержки связанные с недостаточной производительностью оборудования. Их достаточно много. К основным можно отнести:
        1.1.1. Сетевые Латчи возникают когда необходимо передавать большие объёмы результирующих данных по сети, а канал недостаточно широк. Исправляется расширением канала либо уменьшением количестов перегоняемых данных
        1.1.2. Латчи, связанные с очередью физического носителя. Связаны с недостаточной скоростью физического носителя. На сегодняшний момент можно устанавливать SSD в параллельных Raid (RAID0 или RAID10).
        1.1.3. Проблемы при параллельной обработке запросов. Запрос делится на параллельные потоки и в момент соединения данных обратно возникают задержки ожидания получения результатов от разных потоков. Зачастую необходимо снижать максмиальную степень распараллеливания.
    1.2. Блокировки - задержки связанные с ожиданием окончания другой транзакции. Для исправления необходимо:
        1.2.1. Уменьшать время выполнения транзакции, т.е. уменьшать количестов команд, входящих в транзакцию. Убирать из транзакции команды, которые там не нужны.
        1.2.2. Понижать уровни изоляции. Часто можно использовать более низкие уровни изоляции вплоть до Read Uncommited при получении отчётов или некритичных данных.
        1.2.3. Использовать специфичные уровни изоляции типа Snapshot или Read Commited SnapShop. Эти уровни изоляции (приминительно к MSSQL) позволяют не блокировать чтение изменяемых в транзакции данных.
    1.3. Дедлоки - взаимоблокирующие транзакции, которые приводят к откату одной из транзакции, что приводит к задержкам и необходимости запустить последний процесс повторно. Исправляется:
         1.3.1 Уменьшением количества строк, учавствующих в блокировки (например удалять или обновлять по частям)
         1.3.2. Использованием одних и тех же индексов при блокировке, чтобы порядок блокировки строк был одним и тем же
         1.3.3. Блокировкой необходимых данных в самом начале транзакции, чтобы другие транзакции не смогли заблокировать необходимые для текущей транзакции данные.
2. В каких случаях индекс в MySQL не будет применятся, даже если он доступен и выборка должна использовать его?
    Индекс не будет применён если СУБД решит, что применение индекса нецелесообразно в случаях:
    2.1. Текущая статистика индекса не соответствует реальному положению дел. Исправляется перестройкой статистики по индексу.
    2.2. Если у индекса невысокое покрытие. В этом случае СУБД считает, что лучше использовать сканирование таблицы или использовать другой индекс с более высоким покрытием.
    2.3. Когда при обработке будут обработано большая часть строк таблицы. В этом случае СУБД считает, что сканирование таблицы (или того же индекса) более выгодно.
3. Как принудительно применить индекс?
    Для этого используются хинты (подсказки)
        SELECT * FROM table1 USE INDEX (col1_index,col2_index) WHERE col1=1 AND col2=2;
    В MSSQL возможно также указать тип обхода индекса (Seek или Scan)
